"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkAvailability = exports.existingBackend = exports.toJob = exports.fromGCFv1Function = exports.toGCFv1Function = exports.scheduleIdForFunction = exports.topicName = exports.scheduleName = exports.sameFunctionName = exports.functionName = exports.isEmptyBackend = exports.empty = exports.isValidRuntime = exports.isEventTrigger = void 0;
const proto = require("../../gcp/proto");
const gcf = require("../../gcp/cloudfunctions");
const utils = require("../../utils");
const error_1 = require("../../error");
const logger_1 = require("../../logger");
function isEventTrigger(trigger) {
    return "eventType" in trigger;
}
exports.isEventTrigger = isEventTrigger;
const RUNTIMES = ["nodejs10", "nodejs12", "nodejs14"];
function isValidRuntime(runtime) {
    return RUNTIMES.includes(runtime);
}
exports.isValidRuntime = isValidRuntime;
function empty() {
    return {
        requiredAPIs: {},
        cloudFunctions: [],
        schedules: [],
        topics: [],
    };
}
exports.empty = empty;
function isEmptyBackend(backend) {
    return (Object.keys(backend.requiredAPIs).length == 0 &&
        backend.cloudFunctions.length === 0 &&
        backend.schedules.length === 0 &&
        backend.topics.length === 0);
}
exports.isEmptyBackend = isEmptyBackend;
function functionName(cloudFunction) {
    return `projects/${cloudFunction.project}/locations/${cloudFunction.region}/functions/${cloudFunction.id}`;
}
exports.functionName = functionName;
exports.sameFunctionName = (func) => (test) => {
    return func.id === test.id && func.region === test.region && func.project == test.project;
};
function scheduleName(schedule, appEngineLocation) {
    return `projects/${schedule.project}/locations/${appEngineLocation}/jobs/${schedule.id}`;
}
exports.scheduleName = scheduleName;
function topicName(topic) {
    return `projects/${topic.project}/topics/${topic.id}`;
}
exports.topicName = topicName;
function scheduleIdForFunction(cloudFunction) {
    return `firebase-schedule-${cloudFunction.id}-${cloudFunction.region}`;
}
exports.scheduleIdForFunction = scheduleIdForFunction;
function toGCFv1Function(cloudFunction, sourceUploadUrl) {
    if (cloudFunction.apiVersion != 1) {
        throw new error_1.FirebaseError("Trying to create a v1 CloudFunction with v2 API. This should never happen");
    }
    const gcfFunction = {
        name: functionName(cloudFunction),
        sourceUploadUrl: sourceUploadUrl,
        entryPoint: cloudFunction.entryPoint,
        runtime: cloudFunction.runtime,
    };
    if (isEventTrigger(cloudFunction.trigger)) {
        gcfFunction.eventTrigger = {
            eventType: cloudFunction.trigger.eventType,
            resource: cloudFunction.trigger.eventFilters.resource,
        };
        gcfFunction.eventTrigger.failurePolicy = cloudFunction.trigger.retry
            ? { retry: {} }
            : undefined;
    }
    else {
        gcfFunction.httpsTrigger = {
            securityLevel: cloudFunction.trigger.allowInsecure ? "SECURE_OPTIONAL" : "SECURE_ALWAYS",
        };
    }
    proto.copyIfPresent(gcfFunction, cloudFunction, "serviceAccountEmail", "timeout", "availableMemoryMb", "minInstances", "maxInstances", "vpcConnector", "vpcConnectorEgressSettings", "ingressSettings", "labels", "environmentVariables");
    return gcfFunction;
}
exports.toGCFv1Function = toGCFv1Function;
function fromGCFv1Function(gcfFunction) {
    var _a;
    const [, project, , region, , id] = gcfFunction.name.split("/");
    let trigger;
    if (gcfFunction.httpsTrigger) {
        trigger = {
            allowInsecure: gcfFunction.httpsTrigger.securityLevel !== "SECURE_ALWAYS",
        };
    }
    else {
        trigger = {
            eventType: gcfFunction.eventTrigger.eventType,
            eventFilters: {
                resource: gcfFunction.eventTrigger.resource,
            },
            retry: !!((_a = gcfFunction.eventTrigger.failurePolicy) === null || _a === void 0 ? void 0 : _a.retry),
        };
    }
    if (!isValidRuntime(gcfFunction.runtime)) {
        logger_1.logger.debug("GCFv1 function has a deprecated runtime:", JSON.stringify(gcfFunction, null, 2));
    }
    const cloudFunction = {
        apiVersion: 1,
        id,
        project,
        region,
        trigger,
        entryPoint: gcfFunction.entryPoint,
        runtime: gcfFunction.runtime,
    };
    proto.copyIfPresent(cloudFunction, gcfFunction, "serviceAccountEmail", "availableMemoryMb", "timeout", "minInstances", "maxInstances", "vpcConnector", "vpcConnectorEgressSettings", "ingressSettings", "labels", "environmentVariables");
    return cloudFunction;
}
exports.fromGCFv1Function = fromGCFv1Function;
function toJob(schedule, appEngineLocation) {
    const job = {
        name: scheduleName(schedule, appEngineLocation),
        schedule: schedule.schedule,
    };
    proto.copyIfPresent(job, schedule, "retryConfig");
    if (schedule.transport === "https") {
        throw new error_1.FirebaseError("HTTPS transport for scheduled functions is not yet supported");
    }
    job.pubsubTarget = {
        topicName: topicName(schedule),
        attributes: {
            scheduled: "true",
        },
    };
    return job;
}
exports.toJob = toJob;
async function existingBackend(context) {
    const ctx = context;
    if (!ctx.loadedExistingBackend) {
        await loadExistingBackend(ctx);
    }
    return ctx.existingBackend;
}
exports.existingBackend = existingBackend;
async function loadExistingBackend(ctx) {
    var _a;
    ctx.loadedExistingBackend = true;
    ctx.existingBackend = {
        requiredAPIs: {},
        cloudFunctions: [],
        schedules: [],
        topics: [],
    };
    ctx.unreachableRegions = {
        gcfv1: [],
    };
    const { functions, unreachable } = await gcf.listAllFunctions(ctx.projectId);
    for (const apiFunction of functions) {
        const specFunction = fromGCFv1Function(apiFunction);
        ctx.existingBackend.cloudFunctions.push(specFunction);
        const isScheduled = ((_a = apiFunction.labels) === null || _a === void 0 ? void 0 : _a["deployment-scheduled"]) === "true";
        if (isScheduled) {
            const id = scheduleIdForFunction(specFunction);
            ctx.existingBackend.schedules.push({
                id,
                project: specFunction.project,
                transport: "pubsub",
                targetService: {
                    id: specFunction.id,
                    region: specFunction.region,
                    project: specFunction.project,
                },
            });
            ctx.existingBackend.topics.push({
                id,
                project: specFunction.project,
                targetService: {
                    id: specFunction.id,
                    region: specFunction.region,
                    project: specFunction.project,
                },
            });
        }
    }
    ctx.unreachableRegions.gcfv1 = [...unreachable];
}
async function checkAvailability(context, want) {
    const ctx = context;
    if (!ctx.loadedExistingBackend) {
        await loadExistingBackend(ctx);
    }
    const gcfv1Regions = new Set();
    want.cloudFunctions
        .filter((fn) => fn.apiVersion === 1)
        .forEach((fn) => gcfv1Regions.add(fn.region));
    const neededUnreachableRegions = ctx.unreachableRegions.gcfv1.filter((region) => gcfv1Regions.has(region));
    if (neededUnreachableRegions.length) {
        throw new error_1.FirebaseError("The following Cloud Functions regions are currently unreachable:\n\t" +
            neededUnreachableRegions.join("\n\t") +
            "\nThis deployment contains functions in those regions. Please try again in a few minutes, or exclude these regions from your deployment.");
    }
    else if (ctx.unreachableRegions.gcfv1.length) {
        utils.logLabeledWarning("functions", "The following Cloud Functions regions are currently unreachable:\n" +
            ctx.unreachableRegions.gcfv1.join("\n") +
            "\nCloud Functions in these regions won't be deleted.");
    }
}
exports.checkAvailability = checkAvailability;
